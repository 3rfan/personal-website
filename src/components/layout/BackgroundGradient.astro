<canvas id="ascii-canvas" class="fixed inset-0 -z-10 h-full w-full"></canvas>

<script>

  // CONFIGURATION
  const CONFIG = {
    // Grid settings
    cellSize: 30,                // Space between characters (20-50)
    
    // Character appearance
    fontSize: 13,                // Size of characters (10-16)
    opacity: 0.7,                // Base opacity (0.2-0.6)
    
    // Character set (what appears on screen)
    characters: ['0', '1', '·', '∙', '○', '◦','3'],  // Available characters
    
    // Animation
    flickerSpeed: 0.01,          // How often chars randomly change (0-0.1, lower = less)
    mouseRadius: 120,            // Distance mouse affects characters
    mouseIntensity: 0.5,         // How much mouse changes opacity (0-1)
    
    // Density
    density: 0.6,                // How many cells have characters (0-1)
    
    // Colors
    useThemeColors: true,        // Use your theme's primary color
    customColor: '180, 70%, 60%',  // HSL color if useThemeColors = false (comma-separated for canvas)
  }
  // ============================

  let canvas: HTMLCanvasElement | null = null
  let ctx: CanvasRenderingContext2D | null = null

  let grid: Cell[] = []
  let mouse = { x: -1000, y: -1000 }
  let color = '180, 70%, 60%'
  let animationId: number
  let observer: MutationObserver | null = null
  let mouseMoveHandler: ((e: MouseEvent) => void) | null = null
  let mouseLeaveHandler: (() => void) | null = null

  function updateColor() {
    const isDark = document.documentElement.classList.contains('dark')
    
    if (CONFIG.useThemeColors) {
      // Black in light mode, greenish in dark mode
      // Canvas requires comma-separated HSL format
      color = isDark ? '150, 60%, 50%' : '0, 0%, 0%'
    } else {
      color = CONFIG.customColor
    }
  }

  class Cell {
    x: number
    y: number
    char: string
    baseOpacity: number
    flickerTimer: number

    constructor(x: number, y: number) {
      this.x = x
      this.y = y
      this.char = this.randomChar()
      this.baseOpacity = CONFIG.opacity * (0.5 + Math.random() * 0.5)
      this.flickerTimer = Math.random()
    }

    randomChar(): string {
      return CONFIG.characters[Math.floor(Math.random() * CONFIG.characters.length)]
    }

    update() {
      // Random flickering - occasionally change character
      this.flickerTimer += CONFIG.flickerSpeed
      if (this.flickerTimer > 1) {
        this.flickerTimer = 0
        if (Math.random() < 0.1) {  // 10% chance to change
          this.char = this.randomChar()
        }
      }
    }

    draw() {
      if (!ctx) return

      // Calculate distance to mouse
      const dx = this.x - mouse.x
      const dy = this.y - mouse.y
      const distance = Math.sqrt(dx * dx + dy * dy)

      // Opacity changes based on mouse proximity
      let opacity = this.baseOpacity
      if (distance < CONFIG.mouseRadius) {
        const influence = 1 - (distance / CONFIG.mouseRadius)
        opacity += influence * CONFIG.mouseIntensity
        opacity = Math.min(opacity, 1)
      }

      ctx.fillStyle = `hsla(${color}, ${opacity})`
      ctx.fillText(this.char, this.x, this.y)
    }
  }

  function createGrid() {
    if (!canvas) return
    grid = []
    
    const cols = Math.ceil(canvas.width / CONFIG.cellSize)
    const rows = Math.ceil(canvas.height / CONFIG.cellSize)

    for (let i = 0; i < cols; i++) {
      for (let j = 0; j < rows; j++) {
        // Only create cell based on density setting
        if (Math.random() < CONFIG.density) {
          const x = i * CONFIG.cellSize + CONFIG.cellSize / 2
          const y = j * CONFIG.cellSize + CONFIG.cellSize / 2
          grid.push(new Cell(x, y))
        }
      }
    }
  }

  function animate() {
    if (!ctx || !canvas) return

    ctx.clearRect(0, 0, canvas.width, canvas.height)

    grid.forEach(cell => {
      cell.update()
      cell.draw()
    })

    animationId = requestAnimationFrame(animate)
  }

  function cleanup() {
    // Stop animation
    if (animationId) {
      cancelAnimationFrame(animationId)
    }
    
    // Remove event listeners
    if (mouseMoveHandler) {
      window.removeEventListener('mousemove', mouseMoveHandler)
    }
    if (mouseLeaveHandler) {
      window.removeEventListener('mouseleave', mouseLeaveHandler)
    }
    window.removeEventListener('resize', resize)
    
    // Disconnect observer
    if (observer) {
      observer.disconnect()
      observer = null
    }
    
    // Clear grid
    grid = []
    
    // Clear context to allow GC
    canvas = null
    ctx = null
  }

  function resize() {
    if (!canvas || !ctx) return
    canvas.width = window.innerWidth
    canvas.height = window.innerHeight
    
    if (ctx) {
      ctx.font = `${CONFIG.fontSize}px monospace`
      ctx.textAlign = 'center'
      ctx.textBaseline = 'middle'
    }
    
    createGrid()
  }

  function init() {
    // Clean up any existing instances first
    cleanup()

    canvas = document.getElementById('ascii-canvas') as HTMLCanvasElement
    if (!canvas) return
    ctx = canvas.getContext('2d')

    updateColor()
    resize()

    // Mouse tracking (store references for cleanup)
    mouseMoveHandler = (e: MouseEvent) => {
      mouse.x = e.clientX
      mouse.y = e.clientY
    }
    mouseLeaveHandler = () => {
      mouse.x = -1000
      mouse.y = -1000
    }
    
    window.addEventListener('mousemove', mouseMoveHandler)
    window.addEventListener('mouseleave', mouseLeaveHandler)
    window.addEventListener('resize', resize)

    // Theme change observer
    observer = new MutationObserver(() => updateColor())
    observer.observe(document.documentElement, { 
      attributes: true, 
      attributeFilter: ['class'] 
    })

    animate()
  }


  document.addEventListener('astro:page-load', init)
  document.addEventListener('astro:before-preparation', cleanup)
</script>